# Design Document

## Overview

This design addresses the missing `/api/proposals` API endpoint that is causing 404 errors in the fiber link calculator and other proposal-related components. The solution will implement a Next.js API route that handles both GET and POST requests for proposal management, integrating with the existing Firebase Firestore database.

## Architecture

The API will follow Next.js App Router conventions and be implemented as a route handler at `src/app/api/proposals/route.ts`. The architecture will include:

- **API Route Handler**: Next.js route handler for HTTP methods (GET, POST)
- **Firebase Integration**: Direct integration with Firestore for data persistence
- **Authentication**: Token-based authentication using existing auth system
- **Type Safety**: Full TypeScript integration using existing Proposal interface
- **Error Handling**: Comprehensive error handling with appropriate HTTP status codes

## Components and Interfaces

### API Route Structure
```typescript
// src/app/api/proposals/route.ts
export async function GET(request: NextRequest): Promise<NextResponse>
export async function POST(request: NextRequest): Promise<NextResponse>
```

### Request/Response Interfaces

**GET Request:**
- Query Parameters: `type` (optional) - filters proposals by type (e.g., "FIBER")
- Headers: `Authorization: Bearer <token>` (optional)
- Response: Array of Proposal objects or empty array

**POST Request:**
- Body: Proposal object (without id, createdAt)
- Headers: `Authorization: Bearer <token>` (optional)
- Response: Created Proposal object with generated id and timestamp

### Data Models

The API will use the existing `Proposal` interface from `src/lib/types.ts`:

```typescript
interface Proposal {
  id: string;
  baseId: string;
  version: number;
  title: string;
  client: string;
  value: number;
  status: 'Rascunho' | 'Enviada' | 'Em Análise' | 'Aprovada' | 'Rejeitada' | 'Aguardando aprovação desconto Diretoria' | 'Aguardando Aprovação do Cliente' | 'Fechado Ganho' | 'Perdido';
  createdBy: string;
  accountManager: string;
  createdAt: any; // Firestore Timestamp
  distributorId: string;
  date: string;
  expiryDate: string;
}
```

### Firestore Collection Structure
- Collection: `proposals`
- Document ID: Auto-generated by Firestore
- Additional field: `type` (string) - to support filtering by proposal type

## Error Handling

### HTTP Status Codes
- **200**: Successful GET request
- **201**: Successful POST request (resource created)
- **400**: Bad request (invalid data, validation errors)
- **401**: Unauthorized (invalid or missing token)
- **405**: Method not allowed
- **500**: Internal server error

### Error Response Format
```typescript
{
  error: string;
  message: string;
  details?: any;
}
```

### Error Scenarios
1. **Database Connection Failures**: Return 500 with generic error message
2. **Invalid Request Data**: Return 400 with validation details
3. **Authentication Failures**: Return 401 with auth error message
4. **Firestore Operation Failures**: Return 500 with operation error

## Testing Strategy

### Unit Tests
- Test GET endpoint with and without type filter
- Test POST endpoint with valid and invalid data
- Test authentication token validation
- Test error handling scenarios

### Integration Tests
- Test end-to-end flow from frontend component to database
- Test Firebase Firestore integration
- Test authentication flow

### Manual Testing
- Test with existing FiberLinkCalculator component
- Verify proposals are saved and retrieved correctly
- Test error scenarios in browser console

## Implementation Considerations

### Authentication
- Extract and validate Bearer tokens from Authorization header
- Handle cases where authentication is optional vs required
- Maintain compatibility with existing auth system

### Data Validation
- Validate required fields for POST requests
- Sanitize input data to prevent injection attacks
- Ensure data types match Proposal interface

### Performance
- Implement efficient Firestore queries with proper indexing
- Use Firestore's built-in filtering for type-based queries
- Consider pagination for large datasets (future enhancement)

### Backwards Compatibility
- Ensure API responses match expected format from existing frontend code
- Maintain existing error handling patterns in frontend components
- Support both authenticated and unauthenticated requests as needed